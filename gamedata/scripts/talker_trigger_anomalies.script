--------------------------------------------------------------------------------------------
-- PLAYER INTERACTS WITH ANOMALY
-- Not damaged by it, but affected by it
-- Typically this is a gravitational anomaly or radiation
-- This script was a port from STALKER 1 and may need cleanup
--------------------------------------------------------------------------------------------
package.path = package.path .. ";./bin/lua/?.lua;"
local log = require("framework.logger")
local game = require("infra.game_adapter")
local trigger = require("interface.trigger")
-- Import game interface modules
local queries = talker_game_queries
local mcm = talker_mcm

-- EventType shorthand for cleaner code
local EventType = trigger.EventType

----------------------------------------------------------------------------------------------------
-- Constants
----------------------------------------------------------------------------------------------------
local INTERACTION_DISTANCE = 1
local ANOMALY_PROXIMITY_COMMENT_CD = mcm.get("anomaly_proximity_comment_cd") * 1000
local ANOMALY_DAMAGE_COMMENT_CD = mcm.get("anomaly_damage_comment_cd") * 1000
local MAX_RANK_FOR_WARNING = mcm.get("max_rank_for_warning")

local mode_proximity = tonumber(mcm.get("enable_trigger_proximity_anomalies") or "0")
local mode_damage = tonumber(mcm.get("enable_trigger_damage_anomalies") or "0")
local ANTI_SPAM_CD = mcm.get("anti_spam_cd") * 1000

----------------------------------------------------------------------------------------------------
-- Conditions
----------------------------------------------------------------------------------------------------
local LAST_ANOMALY_PROXIMITY_COMMENT = 0
local LAST_ANOMALY_DAMAGE_COMMENT = 0
local LAST_ANOMALY_PROXIMITY_SPAM = 0
local LAST_ANOMALY_DAMAGE_SPAM = 0

-- Helper to determine if an anomaly event should be silent
-- Mode: 0 = On, 1 = Off, 2 = Silent
local function get_silence_status(mode, is_damage)
    
    local current_time = queries.get_game_time_ms()
    local cooldown = is_damage and ANOMALY_DAMAGE_COMMENT_CD or ANOMALY_PROXIMITY_COMMENT_CD
    local last_time = is_damage and LAST_ANOMALY_DAMAGE_COMMENT or LAST_ANOMALY_PROXIMITY_COMMENT
    local last_spam = is_damage and LAST_ANOMALY_DAMAGE_SPAM or LAST_ANOMALY_PROXIMITY_SPAM
    
    -- 1. Anti-spam check (prevents any event registration if too frequent)
    if (current_time - last_spam) < ANTI_SPAM_CD then
        return nil -- Abort, too soon even for a silent event
    end

    -- Update anti-spam timer now that we know we're registering SOMETHING
    if is_damage then 
        LAST_ANOMALY_DAMAGE_SPAM = current_time 
    else 
        LAST_ANOMALY_PROXIMITY_SPAM = current_time 
    end

    -- 2. Dialogue Cooldown check
    local dialogue_ready = (current_time - last_time) >= cooldown

    if mode == 0 then -- Mode: On
        if dialogue_ready then
            -- Reset the dialogue cooldown timer
            if is_damage then 
                LAST_ANOMALY_DAMAGE_COMMENT = current_time 
            else 
                LAST_ANOMALY_PROXIMITY_COMMENT = current_time 
            end
            return false -- Dialogue requested
        else
            return true -- Silent event (anti-spam passed, but dialogue CD not ready)
        end
    elseif mode == 2 then -- Mode: Silent
        return true -- Always silent if anti-spam passed
    end

    return nil -- Should not reach here if logic is sound (Mode: Off handled at call sites)
end

function is_valid_proximity_event(anomaly)
    local player = queries.get_player()
    
    -- Rank Check: Only warn inexperienced players
    local player_rank_name = queries.get_rank(player)
    local player_rank_val = queries.get_rank_value(player_rank_name)

    if player_rank_val > MAX_RANK_FOR_WARNING then
        return false
    end

    return queries.distance_between(player, anomaly) > INTERACTION_DISTANCE
end

----------------------------------------------------------------------------------------------------
-- Function
----------------------------------------------------------------------------------------------------

function create_anomaly_interaction_event(anomaly_name, is_damage, is_silent)
    local player = game.get_player_character()

    -- Create typed event context
    local context = {
        actor = player,
        anomaly_type = anomaly_name
    }

    -- Use new typed event system
    trigger.talker_event_near_player(
        EventType.ANOMALY,
        context,
        is_damage, -- important only if damage
        { is_silent = is_silent }
    )

    if is_silent then
        log.info("TALKER: Anomaly event registered (silent)")
    end
end

--------------------------------------------------------------------------------------------
-- Main functions
--------------------------------------------------------------------------------------------

-- Anomaly interaction (Proximity)
function actor_on_feeling_anomaly(anomaly)
    if mode_proximity == 1 then return end

    local section = anomaly:section()
    if string.find(section, "radioactive") or string.find(section, "radiation") then
        return
    end

    local anomaly_name = queries.load_xml(section)
    if anomaly_name == "" then return end -- Not a supported anomaly

    -- Skip if the anomaly is not close enough OR if player rank is too high
    if is_valid_proximity_event(anomaly) then
        local is_silent = get_silence_status(mode_proximity, false)
        if is_silent ~= nil then
            create_anomaly_interaction_event(anomaly_name, false, is_silent)
        end
    end
end

-- Anomaly hit (Damage)
function actor_on_hit_callback(obj, amount, local_direction, who, bone_index)
    if mode_damage == 1 then return end
    if not who then return end
    
    -- Check if the source of damage is an anomaly we recognize
    local section = who:section()
    local anomaly_name = queries.load_xml(section)
    
    -- If load_xml returns an empty string, it's not in our list of supported anomalies
    if anomaly_name == "" then return end
    
    if string.find(section, "radioactive") or string.find(section, "radiation") then
        return
    end

    local is_silent = get_silence_status(mode_damage, true)
    if is_silent ~= nil then
        create_anomaly_interaction_event(anomaly_name, true, is_silent)
    end
end

----------------------------------------------------------------------------------------------------
-- Set up
----------------------------------------------------------------------------------------------------

function safe_actor_on_feeling_anomaly(anomaly)
    local status, err = pcall(actor_on_feeling_anomaly, anomaly)
    if not status then
        log.error("Error in actor_on_feeling_anomaly: %s", err)
    end
end

function safe_actor_on_hit_callback(obj, amount, local_direction, who, bone_index)
    local status, err = pcall(actor_on_hit_callback, obj, amount, local_direction, who, bone_index)
    if not status then
        log.error("Error in actor_on_hit_callback: %s", err)
    end
end

function on_game_start()
    RegisterScriptCallback("actor_on_feeling_anomaly", safe_actor_on_feeling_anomaly)
    RegisterScriptCallback("actor_on_hit_callback", safe_actor_on_hit_callback)
end

-- Module loaded check
function is_loaded()
    return true
end

function insert_interface(new_interface)
    interface = new_interface
end
