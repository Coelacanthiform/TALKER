----------------------------------------------------------------------------------------------------
-- Artifact use and pick-ups
----------------------------------------------------------------------------------------------------

package.path = package.path .. ";./bin/lua/?.lua;"
local game = require("infra.game_adapter")
local trigger = require("interface.trigger")
local logger = require("framework.logger")

local queries = talker_game_queries
local commands = talker_game_commands
local mcm = talker_mcm

-- EventType shorthand for cleaner code
local EventType = trigger.EventType

----------------------------------------------------------------------------------------------------
-- Constants
----------------------------------------------------------------------------------------------------
local ARTIFACT_PICKUP_COMMENT_CD = mcm.get("artifact_pickup_comment_cd") * 1000
local ARTIFACT_USE_COMMENT_CD = mcm.get("artifact_use_comment_cd") * 1000
local ARTIFACT_EQUIP_COMMENT_CD = mcm.get("artifact_equip_comment_cd") * 1000

local mode_pickup = tonumber(mcm.get("enable_trigger_artifact_pickup") or "0")
local mode_use = tonumber(mcm.get("enable_trigger_artifact_use") or "0")
local mode_equip = tonumber(mcm.get("enable_trigger_artifact_equip") or "0")
local ANTI_SPAM_CD = mcm.get("anti_spam_cd") * 1000

local LOAD_SAFE = false
----------------------------------------------------------------------------------------------------
-- Conditions
----------------------------------------------------------------------------------------------------
local function is_excluded_artifact(name)
    if not name then return false end
    local lower_name = string.lower(name)
    if string.find(lower_name, "oxygen") or string.find(lower_name, "filter") then
        return true
    end
    return false
end

local LAST_ARTIFACT_PICKUP_COMMENT = 0
local LAST_ARTIFACT_USE_COMMENT = 0
local LAST_ARTIFACT_EQUIP_COMMENT = 0

local LAST_ARTIFACT_PICKUP_SPAM = 0
local LAST_ARTIFACT_USE_SPAM = 0
local LAST_ARTIFACT_EQUIP_SPAM = 0

-- Helper to determine if an artifact event should be silent
-- Mode: 0 = On, 1 = Off, 2 = Silent
-- Trigger types: 1 = pickup, 2 = use, 3 = equip
local function get_silence_status(mode, trigger_type)
    local current_time = queries.get_game_time_ms()
    local cooldown, last_time, last_spam
    
    if trigger_type == 1 then
        cooldown, last_time, last_spam = ARTIFACT_PICKUP_COMMENT_CD, LAST_ARTIFACT_PICKUP_COMMENT, LAST_ARTIFACT_PICKUP_SPAM
    elseif trigger_type == 2 then
        cooldown, last_time, last_spam = ARTIFACT_USE_COMMENT_CD, LAST_ARTIFACT_USE_COMMENT, LAST_ARTIFACT_USE_SPAM
    else
        cooldown, last_time, last_spam = ARTIFACT_EQUIP_COMMENT_CD, LAST_ARTIFACT_EQUIP_COMMENT, LAST_ARTIFACT_EQUIP_SPAM
    end
    
    -- 1. Anti-spam check
    if (current_time - last_spam) < ANTI_SPAM_CD then
        return nil -- Abort, too soon even for a silent event
    end

    -- Update anti-spam timer
    if trigger_type == 1 then LAST_ARTIFACT_PICKUP_SPAM = current_time 
    elseif trigger_type == 2 then LAST_ARTIFACT_USE_SPAM = current_time 
    else LAST_ARTIFACT_EQUIP_SPAM = current_time end

    -- 2. Dialogue Cooldown check
    local dialogue_ready = (current_time - last_time) >= cooldown

    if mode == 0 then -- Mode: On
        if dialogue_ready then
            -- Reset the dialogue cooldown timer
            if trigger_type == 1 then LAST_ARTIFACT_PICKUP_COMMENT = current_time 
            elseif trigger_type == 2 then LAST_ARTIFACT_USE_COMMENT = current_time 
            else LAST_ARTIFACT_EQUIP_COMMENT = current_time end
            return false -- Dialogue requested
        else
            return true -- Silent event
        end
    elseif mode == 2 then -- Mode: Silent
        return true
    end

    return nil
end

----------------------------------------------------------------------------------------------------
-- Helper: Create artifact event with typed system
----------------------------------------------------------------------------------------------------

local function create_artifact_event(action, artifact_name, is_silent)
    local player = game.get_player_character()

    -- Create typed event context
    local context = {
        actor = player,
        action = action,
        item_name = artifact_name
    }

    -- Use new typed event system
    trigger.talker_event_near_player(
        EventType.ARTIFACT,
        context,
        true, -- important
        { is_silent = is_silent }
    )

    if is_silent then
        logger.info("TALKER: Artifact event registered (silent)")
    end
end

----------------------------------------------------------------------------------------------------
-- Handlers
----------------------------------------------------------------------------------------------------


local function actor_on_item_use(obj, str)
    if not LOAD_SAFE or mode_use == 1 then return end
    if not queries.is_artifact(obj) then return end
    
    local section = obj:section()
    local artifact_description = queries.load_xml(section)
    if artifact_description == "" then
        artifact_description = queries.get_item_name(obj)
    end

    if is_excluded_artifact(artifact_description) then return end

    local is_silent = get_silence_status(mode_use, 2)
    if is_silent == nil then return end

    create_artifact_event("use", artifact_description, is_silent)
end

local function actor_item_to_belt(obj)
    if not LOAD_SAFE or mode_equip == 1 then return end
    if not queries.is_artifact(obj) then return end
    
    local section = obj:section()
    local artifact_description = queries.load_xml(section)
    if artifact_description == "" then
        artifact_description = queries.get_item_name(obj)
    end

    if is_excluded_artifact(artifact_description) then return end

    local is_silent = get_silence_status(mode_equip, 3)
    if is_silent == nil then return end

    create_artifact_event("equip", artifact_description, is_silent)
end

local function actor_on_item_to_slot(obj)
    if not LOAD_SAFE or mode_equip == 1 then return end
    if not queries.is_artifact(obj) then return end
    
    local section = obj:section()
    local artifact_description = queries.load_xml(section)
    if artifact_description == "" then
        artifact_description = queries.get_item_name(obj)
    end

    if is_excluded_artifact(artifact_description) then return end

    local is_silent = get_silence_status(mode_equip, 3)
    if is_silent == nil then return end

    create_artifact_event("equip", artifact_description, is_silent)
end

local function actor_on_item_before_pickup(obj)
    if not LOAD_SAFE or mode_pickup == 1 then return end
    if not queries.is_artifact(obj) then return end

    local section = obj:section()
    local artifact_description = queries.load_xml(section)
    
    -- If load_xml returns an empty string, fall back to the basic item name
    if artifact_description == "" then
        artifact_description = queries.get_item_name(obj)
    end
    
    if is_excluded_artifact(artifact_description) then return end

    local is_silent = get_silence_status(mode_pickup, 1)
    if is_silent == nil then return end

    create_artifact_event("pickup", artifact_description, is_silent)
end



----------------------------------------------------------------------------------------------------
-- Setup
----------------------------------------------------------------------------------------------------

local function on_loading_screen_dismissed()
    -- Wait 3 seconds after loading screen is gone before enabling triggers
    -- to avoid engine-driven equipment calls
    CreateTimeEvent("talker_artifact_load", "safe_enable", 3, function()
        LOAD_SAFE = true
        logger.info("Artifact triggers are now LOAD_SAFE and active.")
        return true
    end)
end

function on_game_start()
    RegisterScriptCallback("on_loading_screen_dismissed", on_loading_screen_dismissed)
    commands.RegisterSafeScriptCallback("actor_on_item_before_pickup", actor_on_item_before_pickup)
    commands.RegisterSafeScriptCallback("actor_on_item_use", actor_on_item_use)
    commands.RegisterSafeScriptCallback("actor_on_item_to_slot", actor_on_item_to_slot)
    commands.RegisterSafeScriptCallback("actor_item_to_belt", actor_item_to_belt)
end

function is_loaded()
    return true
end
