---@diagnostic disable: undefined-global
package.path = package.path .. ";./bin/lua/?.lua;"
local game = require("infra.game_adapter")
local trigger = require("interface.trigger")
local log = require("framework.logger")

-- Import game interface modules
local queries = talker_game_queries
local mcm = talker_mcm

-- EventType shorthand for cleaner code
local EventType = trigger.EventType
----------------------------------------------------------------------------------------------------
-- INFO
----------------------------------------------------------------------------------------------------
-- the callout trigger script is responsible for generating callouts from NPCs to other NPCs
-- on_enemy_eval occurs at high frequency, so we limit the amount of calls

---------------------------------------------------------------------------------------------
-- CONDITIONS
--------------------------------------------------------------------------------------------


local event_store = require("domain.repo.event_store")

local last_callout_time_ms = 0
local callout_cooldown_ms = mcm.get("callout_cooldown") * 1000 -- default 30 seconds, for ANY callout.
local repeated_callout_cooldown_ms = mcm.get("repeated_callout_cooldown") * 1000 -- default 4 minutes, for callouts of enemies with the same name.
local MAX_CALLOUT_DISTANCE = mcm.get("max_callout_distance")  -- default 30 meters, max distance of callout in meters

function is_valid_callout(npc_obj, target_obj)
    -- Perform initial checks. If any of these fail, the callout is invalid.
    if not (
        queries.is_living_character(npc_obj) and
        queries.are_enemies(npc_obj, target_obj) and
        queries.get_distance_between(npc_obj, target_obj) <= MAX_CALLOUT_DISTANCE and
        not queries.is_in_combat(npc_obj)
    ) then
        return false
    end

    -- Global cooldown check
    if (queries.get_game_time_ms() - last_callout_time_ms) < callout_cooldown_ms then
        return false
    end

    -- Companion check
    if queries.is_companion(npc_obj) and not queries.are_enemies(db.actor, target_obj) then
        return false
    end

    if queries.is_companion(target_obj) and not queries.are_enemies(db.actor, npc_obj) then
        return false
    end


    -- Anti-spam check
    -- We check the event store for recent events where a creature with the same name was spotted.
    local target_name = queries.get_name(target_obj)
    local since_time = queries.get_game_time_ms() - repeated_callout_cooldown_ms
    local recent_events = event_store:get_events_since(since_time)    
    for _, event in ipairs(recent_events) do
        if event.description == "%s (%s %s, %s rep) spotted %s (%s %s, %s rep)!" or
        event.description == "%s (%s %s, %s rep) spotted %s (%s faction)!" then
            -- involved_objects: {spotter_name, spotter_rank, spotter_faction, spotter_reputation, target_name, ...}
            local event_target_name = event.involved_objects and event.involved_objects[5]
            if event_target_name then
                if event_target_name == target_name then
                    local time_ago = queries.get_game_time_ms() - event.game_time_ms
                    
                    -- Check if the event actually resulted in a callout (dialogue generated)
                    -- Or if it's very recent (pending), give it a chance (e.g. 15 seconds)
                    local PENDING_WINDOW_MS = 15 * 1000
                    
                    if event.dialogue_generated then
                         log.info("Blocking repeated callout for %s. Similar target spotted %s ms ago (dialogue generated).", target_name, time_ago)
                         return false
                    elseif time_ago < PENDING_WINDOW_MS then
                        log.info("Blocking repeated callout for %s. Similar target spotted %s ms ago (pending).", target_name, time_ago)
                        return false
                    end
                end
            end
        end
    end



    -- All checks passed.
    return true
end

---------------------------------------------------------------------------------------------
-- ENEMY CALLOUTS
--------------------------------------------------------------------------------------------
function on_enemy_eval(npc_obj, target_obj)
    if not mcm.get("enable_trigger_callout") then return end
    
    -- determine if it's a callout
    if not is_valid_callout(npc_obj, target_obj) then return end

    local spotter = game.create_character(npc_obj)
    -- If the character object couldn't be created (e.g., NPC was despawned), abort.
    if not spotter or spotter.faction == "Monster" or spotter.faction == "Zombied" then return end

    local enemy = game.create_character(target_obj)
    -- If the character object couldn't be created (e.g., NPC was despawned), abort.
    if not enemy then return end
    
    if enemy.faction == spotter.faction and not queries.is_companion(npc_obj) then return end

    -- create callout event
    local witnesses = {spotter}

    -- Create typed event context
    local context = {
        spotter = spotter,
        target = enemy
    }
    
    log.info(spotter.name .. " spotted " .. enemy.name)

    -- Use new typed event system
    trigger.talker_event(
        EventType.CALLOUT,
        context,
        witnesses,
        true, -- important
        {}
    )

    -- Update global timer
    last_callout_time_ms = queries.get_game_time_ms()
end

--------------------------------------------------------------------------------------------
-- Set up
--------------------------------------------------------------------------------------------

local function safe_on_enemy_eval(observer_obj, target_obj)
    local status, err = pcall(function()
        on_enemy_eval(observer_obj, target_obj)
    end)
    if not status then
        log.error("Error in on_enemy_eval: " .. err)
    end
end

function on_game_start()
    RegisterScriptCallback("on_enemy_eval", safe_on_enemy_eval)
end

-- for validating all scripts have loaded
function is_loaded()
    return true
end
