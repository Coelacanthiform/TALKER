package.path = package.path .. ";./bin/lua/?.lua;"
local game = require("infra.game_adapter")
local trigger = require("interface.trigger")
local log = require("framework.logger")
local mcm = talker_mcm
-- Game interfaces
local queries = talker_game_queries

local mode_player = tonumber(mcm.get("enable_trigger_death_player") or "0")
local mode_npc = tonumber(mcm.get("enable_trigger_death_npc") or "0")

local DEATH_COOLDOWN_CD_PLAYER = mcm.get("death_cooldown_player") * 1000 -- default 90 seconds cooldown to prevent spam
local DEATH_COOLDOWN_CD_NPC = mcm.get("death_cooldown_npc") * 1000 -- default 90 seconds cooldown to prevent spam

-- Cooldown tracking variables
local LAST_DEATH_TIME_PLAYER = 0
local LAST_DEATH_TIME_NPC = 0

-- Helper to determine if an event should be silent based on MCM mode and cooldown
-- Mode: 0 = On, 1 = Off, 2 = Silent
local function get_silence_status(mode, is_player)
    if mode == 2 then return true end -- Silent mode is always silent
    
    local current_time = queries.get_game_time_ms()
    local cooldown = is_player and DEATH_COOLDOWN_CD_PLAYER or DEATH_COOLDOWN_CD_NPC
    local last_time = is_player and LAST_DEATH_TIME_PLAYER or LAST_DEATH_TIME_NPC
    
    if (current_time - last_time) < cooldown then
        return true -- On cooldown, so silent
    end
    
    -- Not on cooldown and mode is 0 (On), so update timer and speak
    if is_player then 
        LAST_DEATH_TIME_PLAYER = current_time 
    else 
        LAST_DEATH_TIME_NPC = current_time 
    end
    return false
end
--------------------------------------------------------------------------------------------
-- CALLBACK
--------------------------------------------------------------------------------------------

function on_creature_death(victim_obj, killer_obj)
    local is_player = killer_obj and killer_obj:id() == 0
    local mode = is_player and mode_player or mode_npc
    
    if mode == 1 then return end -- Mode 1 = Off: Exit immediately

    -- get and combine witnesses
    local witnesses_near_victim = game.get_characters_near(victim_obj)
    local witnesses_near_killer = {}
    if killer_obj then
        witnesses_near_killer = game.get_characters_near(killer_obj)
    end
    local witnesses = queries.join_tables(witnesses_near_victim, witnesses_near_killer)
    -- make characters
    local killer = nil
    if killer_obj then
        killer = game.create_character(killer_obj)
    end
    local victim = game.create_character(victim_obj)

    -- decide if a character is important
    local function is_important_person(char_obj, char_data)
        if not char_obj or not char_data then return false end
        -- Kills by player or companion are always important
        if queries.is_player(char_obj) or queries.is_companion(char_obj) then return true end
        -- Unique characters are always important
        if queries.is_unique_character_by_id(char_obj:id()) then return true end
        -- High ranked NPCs also count as important
        local rank = string.lower(char_data.experience or "")
        if rank == "master" or rank == "legend" then return true end
        return false
    end
    
    -- Important events always generate dialogue, non-important events use base dialogue chance (default 25%)
    local important_event = false
    if is_important_person(victim_obj, victim) or is_important_person(killer_obj, killer) then
        important_event = true
    end
    
    -- Flag if the death is important for use later
    local important_death = false
    if is_important_person(victim_obj, victim) then
        important_death = true
    end
    local flags = { important_death = important_death, is_death = true }
    
    -- Determine if this should be a silent event based on mode and cooldown
    flags.is_silent = get_silence_status(mode, is_player)
    
    local victim_fmt, victim_vals = queries.get_character_event_info(victim)

    if killer and killer.name ~= victim.name then   
        local killer_fmt, killer_vals = queries.get_character_event_info(killer)
        local unformatted_description = victim_fmt .. " was killed by " .. killer_fmt .. "!"
        local values = queries.join_tables(victim_vals, killer_vals)
        trigger.talker_game_event(unformatted_description, values, witnesses, important_event, flags)
    else
        -- Environmental death or suicide
        local unformatted_description = victim_fmt .. " died!"
        trigger.talker_game_event(unformatted_description, victim_vals, witnesses, important_event, flags)
    end
    if flags.is_silent == true then
        log.info("TALKER: Death event registered (silent)")
    end
end

--------------------------------------------------------------------------------------------
-- Bubble Wrap
--------------------------------------------------------------------------------------------

local function safe_on_creature_death(victim_obj, killer_obj)
    local status, err = pcall(function()
        on_creature_death(victim_obj, killer_obj)
    end)
    if not status then
        log.error("Error in victim_on_death_callback: " .. err)
    end
end

--------------------------------------------------------------------------------------------
-- On Game Start
--------------------------------------------------------------------------------------------

function on_game_start()
    RegisterScriptCallback("npc_on_death_callback", safe_on_creature_death)
    RegisterScriptCallback("monster_on_death_callback", safe_on_creature_death)
end

function is_loaded()
    return true
end
