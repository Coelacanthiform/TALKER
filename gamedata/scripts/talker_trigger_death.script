package.path = package.path .. ";./bin/lua/?.lua;"
local game = require("infra.game_adapter")
local trigger = require("interface.trigger")
local log = require("framework.logger")
local mcm = talker_mcm
-- Game interfaces
local queries = talker_game_queries

--------------------------------------------------------------------------------------------
-- CALLBACK
--------------------------------------------------------------------------------------------

function on_creature_death(victim_obj, killer_obj)
    -- Check if player is killer (ID 0)
    if killer_obj and killer_obj:id() == 0 then
        if not mcm.get("enable_trigger_death_player") then return end
    else
        if not mcm.get("enable_trigger_death_npc") then return end
    end

    -- get and combine witnesses
    local witnesses_near_victim = game.get_characters_near(victim_obj)
    local witnesses_near_killer = {}
    if killer_obj then
        witnesses_near_killer = game.get_characters_near(killer_obj)
    end
    local witnesses = queries.join_tables(witnesses_near_victim, witnesses_near_killer)
    -- make characters
    local killer = nil
    if killer_obj then
        killer = game.create_character(killer_obj)
    end
    local victim = game.create_character(victim_obj)

    -- decide if a character is important
    local function is_important_person(char_obj, char_data)
        if not char_obj or not char_data then return false end
        -- Kills by player or companion are always important
        if queries.is_player(char_obj) or queries.is_companion(char_obj) then return true end
        -- Unique characters are always important
        if queries.is_unique_character_by_id(char_obj:id()) then return true end
        -- High ranked NPCs also count as important
        local rank = string.lower(char_data.experience or "")
        if rank == "master" or rank == "legend" then return true end
        return false
    end
    
    -- Important events always generate dialogue, non-important events use base dialogue chance (default 25%)
    local important_event = false
    if is_important_person(victim_obj, victim) or is_important_person(killer_obj, killer) then
        important_event = true
    end
    
    -- Flag if the death is important for use later
    local important_death = false
    if is_important_person(victim_obj, victim) then
        important_death = true
    end
    local flags = { important_death = important_death, is_death = true }
    local victim_fmt, victim_vals = queries.get_character_event_info(victim)

    if killer and killer.name ~= victim.name then
        local killer_fmt, killer_vals = queries.get_character_event_info(killer)
        local unformatted_description = victim_fmt .. " was killed by " .. killer_fmt .. "!"
        local values = queries.join_tables(victim_vals, killer_vals)
        trigger.talker_game_event(unformatted_description, values, witnesses, important_event, flags)
    else
        -- Environmental death or suicide
        local unformatted_description = victim_fmt .. " died!"
        trigger.talker_game_event(unformatted_description, victim_vals, witnesses, important_event, flags)
    end
end

--------------------------------------------------------------------------------------------
-- Bubble Wrap
--------------------------------------------------------------------------------------------

local function safe_on_creature_death(victim_obj, killer_obj)
    local status, err = pcall(function()
        on_creature_death(victim_obj, killer_obj)
    end)
    if not status then
        log.error("Error in victim_on_death_callback: " .. err)
    end
end

--------------------------------------------------------------------------------------------
-- On Game Start
--------------------------------------------------------------------------------------------

function on_game_start()
    RegisterScriptCallback("npc_on_death_callback", safe_on_creature_death)
    RegisterScriptCallback("monster_on_death_callback", safe_on_creature_death)
end

function is_loaded()
    return true
end
