--------------------------------------------------------------------------------
-- LEVEL CHANGE COMMENTS
--------------------------------------------------------------------------------

-- Imports
package.path = package.path .. ";./bin/lua/?.lua;"
local trigger = require("interface.trigger")
local locations = require("infra.STALKER.locations")
local logger = require("framework.logger")
local game = require("infra.game_adapter")
local mcm = talker_mcm
local queries = talker_game_queries

-- EventType shorthand for cleaner code
local EventType = trigger.EventType

-- Saved variable to track the number of visits to each map
local level_visit_count = {}
local commented_already = false

local mode_map_transition = tonumber(mcm.get("enable_trigger_map_transition") or "0")

-- Function to handle map change event
-- @param previous_map String name of the previous map
-- @param current_map String name of the current map
function on_map_change_event(previous_map, current_map)
    if mode_map_transition == 1 then return end
    
    if not current_map or not previous_map then return end

    -- Update visit count for the current map
    level_visit_count[current_map] = (level_visit_count[current_map] or 0) + 1

    -- Determine the number of visits for messaging
    local visit_count = level_visit_count[current_map]

    local player = game.get_player_character()
    local companions = game.get_companions() or {}
    local witnesses = {}
    local previous_map_name = locations.get_location_name(previous_map)
    local current_map_name = locations.get_location_name(current_map)
    local current_map_description = locations.describe_location_detailed(current_map)
    
    -- Build witness list
    for _, companion in ipairs(companions) do
        witnesses[#witnesses+1] = companion
    end
    witnesses[#witnesses+1] = player

    -- Create typed event context
    local context = {
        actor = player,
        source = previous_map_name,
        destination = current_map_name,
        visit_count = visit_count,
        destination_description = current_map_description,
        companions = companions
    }

    local is_silent = (mode_map_transition == 2)

    -- Use new typed event system
    trigger.talker_event(
        EventType.MAP_TRANSITION,
        context,
        witnesses,
        true, -- important
        { is_silent = is_silent }
    )

    if is_silent then
        logger.info("TALKER: Map transition event registered (silent)")
    end
end

local previous_map
function has_map_changed(current_map)
    return previous_map and previous_map ~= current_map
end


function on_loading_screen_dismissed()
    local current_map = level.name()
    if has_map_changed(current_map) then
        on_map_change_event(previous_map, current_map)
    end
end

function on_loading_screen_dismissed_safe()
    local status, err = pcall(on_loading_screen_dismissed)
    if not status then
        logger.error("Error in on_loading_screen_dismissed_safe: " .. err)
    end
end

--------------------------------------------------------------------------------
-- SAVING AND LOADING
--------------------------------------------------------------------------------

-- Function to save the state
function save_state(m_data)
    m_data.level_visit_count = level_visit_count or {}
    m_data.level_visit_count = commented_already
    m_data.previous_map = level.name()
end

-- Function to load the state
function load_state(m_data)
    level_visit_count = m_data.level_visit_count or {}
    commented_already = m_data.commented_already
    previous_map = m_data.previous_map
end

--------------------------------------------------------------------------------
-- callbacks
--------------------------------------------------------------------------------
function on_game_start()
    RegisterScriptCallback("on_level_changing", "on_level_changing")
    RegisterScriptCallback("on_loading_screen_dismissed", on_loading_screen_dismissed_safe)
	RegisterScriptCallback("save_state",save_state)
	RegisterScriptCallback("load_state",load_state)
end

-- Module loaded check
function is_loaded()
    return true
end
