package.path = package.path .. ";./bin/lua/?.lua;"
local log = require("framework.logger")
local config = require("interface.config")
local queries = talker_game_queries
local trigger = require("interface.trigger")
-- Game interface
local game_adapter = require("infra.game_adapter")
local mcm = talker_mcm

local script_name = "TALKER Trigger Task"
local original_task_callback = nil

-- Faction name mapping from technical to display names
local faction_map = {
    killer = "Mercenary",
    dolg = "Duty",
    freedom = "Freedom",
    bandit = "Bandit",
    monolith = "Monolith",
    stalker = "stalker",
    csky = "Clear Sky",
    ecolog = "Ecolog",
    army = "Army",
    renegade = "Renegade",
    trader = "Trader",
    greh = "Sin",
    isg = "ISG",
    zombied = "Zombied",
    monster = "Monster"
}

local LAST_TASK_TIME = 0
local LAST_TASK_SPAM = 0
local TASK_COOLDOWN_CD = mcm.get("task_cooldown") * 1000 -- default 40 seconds cooldown
local ANTI_SPAM_CD = mcm.get("anti_spam_cd") * 1000
local mode_task = tonumber(mcm.get("enable_trigger_task") or "0")

-- Helper to determine if a task event should be silent
-- Mode: 0 = On, 1 = Off, 2 = Silent
local function get_silence_status(mode)
    local current_time = queries.get_game_time_ms()
    
    -- 1. Anti-spam check
    if (current_time - LAST_TASK_SPAM) < ANTI_SPAM_CD then
        log.info("TALKER: Task event aborted (anti-spam)")
        return nil -- Abort, too soon
    end

    -- Update anti-spam timer
    LAST_TASK_SPAM = current_time

    -- 2. Dialogue Cooldown check
    local dialogue_ready = (current_time - LAST_TASK_TIME) >= TASK_COOLDOWN_CD

    if mode == 0 then -- Mode: On
        if dialogue_ready then
            LAST_TASK_TIME = current_time
            return false -- Dialogue requested
        else
            return true -- Silent event
        end
    elseif mode == 2 then -- Mode: Silent
        return true
    end

    return nil
end

function on_game_start()
    -- Hook the task_callback function to intercept task completion
    -- We must capture task info BEFORE the original callback runs, because some mods/tasks 
    -- delete the task info immediately upon completion (race condition).
    if task_manager and task_manager.task_callback then
        original_task_callback = task_manager.task_callback
        task_manager.task_callback = function(tsk, stage)
            
            -- 1. Pre-capture task info
            local cached_info = nil
            local success, err = pcall(function() 
                local task_id = tsk:get_id()
                local tm = task_manager.get_task_manager()
                if tm and tm.task_info and tm.task_info[task_id] then
                     cached_info = tm.task_info[task_id]
                end
            end)
            if not success then
                log.error("%s: Error capturing task info: %s", script_name, err)
            end

            -- 2. Call original callback
            original_task_callback(tsk, stage)
            
            -- 3. Trigger our event if task was completed, using cached info
            if stage == task.completed then
                on_task_completed_event(tsk, cached_info)
            end
        end
        log.info("%s: Hooked task_manager.task_callback with pre-capture", script_name)
    else
        log.error("%s: Could not hook task_manager.task_callback - function not found", script_name)
    end
end

function on_task_completed_event(tsk, cached_info)
    if mode_task == 1 then return end
    if not tsk then return end
    
    local task_id = tsk:get_id()
    local task_info = cached_info
    
    -- Fallback to live info if cache failed/missing (unlikely if hook works, but safe)
    if not task_info then
        local tm = task_manager.get_task_manager()
        if tm and tm.task_info and tm.task_info[task_id] then
            task_info = tm.task_info[task_id]
        end
    end

    if not task_info then
        log.info("%s: Cannot access task info for task %s", script_name, task_id)
        return
    end
    
    local task_giver_id = task_info.task_giver_id
    
    if not task_giver_id then 
        -- Some auto-tasks have no giver (nil), we might want to support them later, 
        -- but for "someone completed a task FOR someone", we need a giver.
        return 
    end
    
    -- Check if task giver is valid
    local server_entity = alife_object(task_giver_id)
    if not server_entity then
        log.info("%s: task giver server object not found, returning", script_name)
        return
    end

    -- Proceed with event: determine if it's silent based on cooldown and chance
    local is_silent = get_silence_status(mode_task)
    if is_silent == nil then return end
    
    local is_unique = queries.is_unique_character_by_id(task_giver_id)
    if not is_unique and mode_task == 0 and not is_silent then
        if math.random() > mcm.get("task_notice_chance") then
            is_silent = true
        end
    end
    
    -- Reputation Fetching
    -- Try to get online object first as it has reliable reputation methods
    local rep_val = 0
    local client_obj = level.object_by_id(task_giver_id)
    if client_obj and client_obj.character_reputation then
        rep_val = client_obj:character_reputation()
    elseif server_entity.reputation then
        -- This property availability on server objects varies by engine version/mod
        -- but usually cse_alife_trader_abstract has it.
        rep_val = server_entity.reputation
    end
    
    local rep_tier = queries.get_reputation_tier(rep_val)

    -- Manually create character info
    local task_giver_character = {
        name = server_entity:character_name(),
        experience = server_entity:rank(), -- Returns number
        faction = tostring(server_entity:community()),
        reputation = rep_tier
    }
    
    -- Try to get text rank name
    if ranks and ranks.get_se_obj_rank_name then
         task_giver_character.experience = ranks.get_se_obj_rank_name(server_entity)
    end

    -- Convert faction technical name to display name
    task_giver_character.faction = faction_map[task_giver_character.faction] or task_giver_character.faction

    -- Task Title from task object
    local task_title = tsk:get_title()
    if not task_title or task_title == "" then
        -- fallback
        local task_id = tsk:get_id()
        if task_manager and task_manager.task_ini and task_manager.task_ini.r_string_ex then
             local title_key = task_manager.task_ini:r_string_ex(task_id, "title")
             if title_key then
                 task_title = game.translate_string(title_key)
             else
                 task_title = game.translate_string(task_id)
             end
        else
             task_title = game.translate_string(task_id)
        end
    else
        -- Smart translation fallback:
        -- If the title looks like a technical key (has underscore, no spaces), try to translate it
        -- This handles cases where get_title() returns the key instead of the text due to engine quirks
        if string.find(task_title, "_") and not string.find(task_title, " ") then
            local translated = game.translate_string(task_title)
            if translated ~= task_title then
                task_title = translated
            end
        end
    end

    local witnesses = game_adapter.get_characters_near_player()
    local player = game_adapter.get_player_character()
    local player_fmt, player_vals = queries.get_character_event_info(player)
    local companions = game_adapter.get_companions() or {}
    
    -- Format Description
    -- Format: "Name (Rank Faction, Reputation rep)"
    -- e.g. "Wolf (Experienced Loner, Excellent rep)"
    local giver_desc_str = string.format("%s (%s %s, %s rep)", 
        task_giver_character.name, 
        task_giver_character.experience, 
        task_giver_character.faction, 
        task_giver_character.reputation
    )

    if #companions > 0 then 
        local names_list = {}
        for _, companion in ipairs(companions) do
            names_list[#names_list+1] = companion.name
            witnesses[#witnesses+1] = companion
        end
        
        local companion_names = ""
        if #names_list == 1 then
            companion_names = names_list[1]
        else
            local last_name = table.remove(names_list)
            companion_names = table.concat(names_list, ", ") .. " and " .. last_name
        end
        -- Format and send the event
        local description = player_fmt .. " and their travelling companions " .. companion_names .. " completed the task '" .. task_title .. "' for " .. giver_desc_str .. "!"
        trigger.talker_game_event(description, player_vals, witnesses, true, { is_task = true, is_silent = is_silent })
     
    else
        local description = player_fmt .. " completed the task '" .. task_title .. "' for " .. giver_desc_str .. "!"
        trigger.talker_game_event(description, player_vals, witnesses, true, { is_task = true, is_silent = is_silent })
        
    end
    
    if is_silent == true then
        log.info("TALKER: Task event registered (silent)")
    end
end

-- Module loaded check
function is_loaded()
    return true
end
