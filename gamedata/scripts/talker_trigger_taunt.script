---@diagnostic disable: undefined-global
package.path = package.path .. ";./bin/lua/?.lua;"

local trigger = require("interface.trigger")
local game = require("infra.game_adapter")
local log = require("framework.logger")
local mcm = talker_mcm

-- Import game interface modules
local queries = talker_game_queries
----------------------------------------------------------------------------------------------------
-- INFO
----------------------------------------------------------------------------------------------------
-- NPCS taunting other NPCs
-- on_enemy_eval occurs at high frequency, so we limit the amount of calls

---------------------------------------------------------------------------------------------
-- CONDITIONS
--------------------------------------------------------------------------------------------
local last_taunt_time_ms = 0
local TAUNT_COOLDOWN_CD = mcm.get("taunt_cooldown") * 1000 -- default 5 minutes

function someone_should_taunt(npc_obj)
    is_valid =
        (queries.get_game_time_ms() - last_taunt_time_ms) > TAUNT_COOLDOWN_CD and
        queries.is_living_character(npc_obj) and
        queries.is_in_combat(npc_obj)
    -- reset cooldown
    if is_valid then last_taunt_time_ms = queries.get_game_time_ms() end
    return is_valid
end

---------------------------------------------------------------------------------------------
-- ENEMY CALLOUTS
--------------------------------------------------------------------------------------------
function on_enemy_eval(npc_obj, enemy_obj) -- could check for human enemy if we wanted
    if not mcm.get("enable_trigger_taunt") then return end

    -- determine if it's a taunt
    if not someone_should_taunt(npc_obj) then return end

    local taunter = game.create_character(npc_obj)
    -- If the character object couldn't be created (e.g., NPC was despawned), abort. Also abort for monsters and zombied (they shouldn't be taunting).
    if not taunter or taunter.faction == "Monster" or taunter.faction == "Zombied" then return end

    local enemy = game.create_character(enemy_obj)
    -- If the character object couldn't be created (e.g., NPC was despawned), abort.
    if not enemy then return end
    
    -- Prevent edge cases where taunter and enemy are the same faction, while still allowing hostile faction companions to taunt their own faction.
    if enemy.faction == taunter.faction and not queries.is_companion(npc_obj) then return end

    -- Safety check for companions, preventing taunt spam in friendly bases while using companions from a hostile faction.
    if queries.is_companion(npc_obj) and not queries.are_enemies(db.actor, enemy_obj) then
        return
    end
    if queries.is_companion(enemy_obj) and not queries.are_enemies(db.actor, npc_obj) then
        return
    end

    --- create callout event
    local witnesses = {taunter}
    local taunter_fmt, taunter_vals = queries.get_character_event_info(taunter)
    local enemy_fmt, enemy_vals = queries.get_character_event_info(enemy)
    
    local unformatted_description = taunter_fmt .. " decides to taunt " .. enemy_fmt .. "!"
    local values = queries.join_tables(taunter_vals, enemy_vals)
    
    trigger.talker_game_event(unformatted_description, values, witnesses, true, { is_taunt = true })
end

--------------------------------------------------------------------------------------------
-- Set up
--------------------------------------------------------------------------------------------

local function safe_on_enemy_eval(observer_obj, enemy_obj)
    local status, err = pcall(function()
        on_enemy_eval(observer_obj, enemy_obj)
    end)
    if not status then
        log.error("Error in on_enemy_eval: " .. err)
    end
end

function on_game_start()
    RegisterScriptCallback("on_enemy_eval", safe_on_enemy_eval)
end

function is_loaded()
    return true
end
